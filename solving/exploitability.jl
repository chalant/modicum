module exploitability

export computeexploitability!

using StaticArrays

using bestresponse
using infosets
using games
using solving
using LinearAlgebra


function computeexploitability!(::Type{T}, gs::G, h::H, br_h::BH, pl::I) where {A, P, I<:Integer, T<:AbstractFloat, G<:AbstractGameState{A, FullSolving, P}, N<:Node, K1<:Integer, K2<:Integer, H<:History{N, K1, K2}, U<:StaticVector, BH<:BRHistory{U, K1, K2}}
    if terminal!(gs) == true
        return -computeutility!(T, gs, pl)[gs.player]
    end

    lgs, n_actions = legalactions!(K2, gs)

    key = infosetkey(gs, gs.player)
    
    info = infoset(h, key)

    utils = @SVector zeros(T, A)

    for i in 1:n_actions
        idx = lgs[i]

        utils = setindex(utils, computeexploitability!(T,
            perform(action(gs, idx), gs, gs.player), 
            History(h, K2(idx)),
            history(br_h, K2(idx)), 
            pl), i)
        
    end

    if gs.player == pl
        val, act_idx = findmax(br_h.strategies[key])
        strat = @SVector zeros(T, A)
        strat = setindex(strat, 1, act_idx)
    else
        strat = SVector{A, T}(info.cum_strategy[1]/sum(info.cum_strategy[1]))
    end

    return -dot(strat, utils)

    # ev = T(0)

    # compute expected value for playing against a strategy for
    # each player
    # for pl in players!(gs)
    #     ev += expectedvalue!(
    #         gs, h, 
    #         br_h, pl, 
    #         ica, 
    #         ist,
    #         init_reach)
    # end

end

end